# Single Profile Mode 暗号化仕様書

## 概要

Single Profile Mode では、agentapi-proxy に送信する機密情報（環境変数、MCP サーバー設定など）を暗号化してローカルストレージに保存し、プロキシ処理時に復号化して送信する仕組みを実装します。API キーは Cookie を通じて管理されるため、暗号化対象には含まれません。

## 背景

現在の実装では、Single Profile Mode の設定情報（API キー、MCP サーバー設定など）が平文でローカルストレージに保存されており、セキュリティ上の課題があります。この仕様書は、これらの機密情報を暗号化して保存し、必要時に復号化する仕組みを定義します。

## 要件

### 機能要件

1. **暗号化・復号化 API の提供**
   - NextJS API Route として `/api/encrypt` と `/api/decrypt` エンドポイントを提供
   - 対称暗号化方式を使用（AES-256-GCM）
   - サーバーサイドで暗号化・復号化を実行

2. **設定情報の暗号化保存**
   - Single Profile の設定保存時に暗号化 API を呼び出し
   - 暗号化されたデータをローカルストレージに保存
   - 暗号化対象：環境変数、MCP サーバー設定（API キーは Cookie で管理）
   - 暗号化時に API トークンのハッシュ値を保存

3. **プロキシ処理時の復号化**
   - `/api/proxy` でのリクエスト処理時に復号化
   - 復号化されたデータを使用して agentapi-proxy にリクエスト転送

### 非機能要件

1. **セキュリティ**
   - 暗号化キーはサーバー環境変数で管理
   - 初期化ベクトル（IV）は各暗号化処理で生成
   - タイムアウト機能による古いデータの無効化
   - API トークンのハッシュ値による検証（XSS 耐性向上）

2. **パフォーマンス**
   - 暗号化・復号化処理の高速化
   - ローカルストレージへの効率的な保存

3. **可用性**
   - 暗号化失敗時の適切なエラーハンドリング
   - 復号化失敗時のフォールバック処理

## アーキテクチャ

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   NextJS API    │    │  agentapi-proxy │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │                 │
│ │ Profile     │ │    │ │ /api/encrypt│ │    │                 │
│ │ Form        │ │◄──►│ │ /api/decrypt│ │    │                 │
│ └─────────────┘ │    │ └─────────────┘ │    │                 │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │                 │
│ │ localStorage│ │    │ │ /api/proxy  │ │◄──►│                 │
│ │ (encrypted) │ │    │ │ (decrypt)   │ │    │                 │
│ └─────────────┘ │    │ └─────────────┘ │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## データフロー

### 1. 設定保存時の暗号化フロー

```
1. ユーザーがProfile設定を入力
2. Frontend → /api/encrypt (設定データを送信)
3. NextJS API が AES-256-GCM で暗号化
4. 暗号化されたデータを Frontend に返却
5. Frontend が暗号化データを localStorage に保存
```

### 2. プロキシ処理時の復号化フロー

```
1. Frontend → /api/proxy (暗号化されたデータをペイロードに含むリクエスト)
2. NextJS API がリクエストペイロードから暗号化データを取得
3. Cookie から API トークンを取得し、ハッシュ値を検証
4. /api/decrypt を内部呼び出しで復号化
5. 復号化されたデータを使用して agentapi-proxy にリクエスト
6. agentapi-proxy からのレスポンスを Frontend に返却
```

## API 仕様

### /api/encrypt

**エンドポイント**: `POST /api/encrypt`

**リクエスト**:
```json
{
  "data": {
    "baseUrl": "https://api.openai.com",
    "mcpServers": [...],
    "environmentVariables": {...}
  },
  "apiTokenHash": "sha256_hash_of_api_token"
}
```

**レスポンス**:
```json
{
  "encryptedData": "encrypted_base64_string",
  "iv": "initialization_vector_base64",
  "timestamp": 1234567890,
  "apiTokenHash": "sha256_hash_of_api_token"
}
```

### /api/decrypt

**エンドポイント**: `POST /api/decrypt`

**リクエスト**:
```json
{
  "encryptedData": "encrypted_base64_string",
  "iv": "initialization_vector_base64",
  "timestamp": 1234567890,
  "apiTokenHash": "sha256_hash_of_api_token"
}
```

**レスポンス**:
```json
{
  "data": {
    "baseUrl": "https://api.openai.com",
    "mcpServers": [...],
    "environmentVariables": {...}
  }
}
```

**注意**: 
- API トークンの検証に失敗した場合は 401 エラーを返す
- ハッシュ値は Cookie から取得した API トークンと比較して検証

### /api/proxy の変更

**現在の実装**: localStorage から直接設定を読み取り

**変更後の実装**: 
1. リクエストペイロードから暗号化データを取得
2. Cookie から API トークンを取得
3. API トークンのハッシュ値を検証
4. 内部で `/api/decrypt` を呼び出し
5. 復号化されたデータを使用してプロキシ処理

**リクエスト例**:
```json
{
  "encryptedConfig": {
    "encryptedData": "encrypted_base64_string",
    "iv": "initialization_vector_base64",
    "timestamp": 1234567890,
    "apiTokenHash": "sha256_hash_of_api_token"
  },
  // その他のプロキシリクエストデータ
}
```

## セキュリティ考慮事項

### 暗号化方式

- **アルゴリズム**: AES-256-GCM
- **キー管理**: 環境変数 `ENCRYPTION_KEY` (32バイト)
- **初期化ベクトル**: 各暗号化処理で生成 (12バイト)
- **タグ**: 認証タグによる整合性検証

### 環境変数

```env
# 暗号化キー（32バイト、base64エンコード）
ENCRYPTION_KEY=your_32_byte_key_in_base64

# オプション：暗号化データの有効期限（秒）
ENCRYPTION_TIMEOUT=86400
```

### セキュリティ制約

1. **暗号化キーの管理**
   - 環境変数として安全に管理
   - 本番環境では適切なキー管理システムを使用

2. **タイムアウト機能**
   - 古い暗号化データの無効化
   - 定期的なキーローテーション対応

3. **API トークン検証**
   - 復号化前に API トークンのハッシュ値を検証
   - Cookie から取得した API トークンと比較
   - 不一致の場合は復号化を拒否（XSS 攻撃への対策）

4. **エラーハンドリング**
   - 暗号化・復号化エラーの適切な処理
   - 機密情報のログ出力禁止
   - API トークン検証エラーの適切な処理

## 実装計画

### Phase 1: 暗号化API実装

1. `/api/encrypt` エンドポイントの実装
2. `/api/decrypt` エンドポイントの実装
3. 暗号化ユーティリティ関数の作成

### Phase 2: フロントエンド統合

1. SingleProfileContext の更新
2. 暗号化API呼び出しの統合
3. エラーハンドリングの実装

### Phase 3: プロキシ機能更新

1. `/api/proxy` の復号化機能実装
2. 既存のlocalStorage読み取り処理の更新
3. エラーハンドリングの強化

## テスト計画

### 単体テスト

- 暗号化・復号化関数のテスト
- API エンドポイントのテスト
- エラーケースのテスト

### 統合テスト

- 設定保存から取得までの一連のフロー
- プロキシ処理での復号化テスト
- セキュリティ要件の検証

### E2E テスト

- Single Profile Mode の完全なユーザーフロー
- 暗号化データの永続化テスト
- エラー状態からの回復テスト

## 移行計画

### 既存データの移行

1. 既存の平文データの検出
2. 暗号化への自動変換
3. 古いデータ形式のサポート維持

### 段階的展開

1. 新規設定は暗号化で保存
2. 既存設定は初回アクセス時に暗号化
3. 一定期間後に平文データサポート終了

## 運用考慮事項

### 監視・ログ

- 暗号化・復号化処理の成功/失敗率
- パフォーマンス指標の監視
- セキュリティインシデントの検知

### バックアップ・災害復旧

- 暗号化キーのバックアップ戦略
- データ復旧手順の策定
- 障害時の対応フロー

---

**作成日**: 2025-07-04  
**バージョン**: 1.1  
**更新日**: 2025-07-04  
**作成者**: Claude Code

### 変更履歴

- v1.1 (2025-07-04)
  - API キーを Cookie 経由で管理する仕様に変更
  - API トークンのハッシュ値検証機能を追加（XSS 対策）
  - プロキシ処理でペイロードから暗号化データを取得する仕様に変更
- v1.0 (2025-07-04)
  - 初版作成